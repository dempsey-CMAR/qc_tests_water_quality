---
format: 
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
editor_options: 
  chunk_output_type: console
params:
  county: county
  depl_file: depl_file
---

```{r, set-up, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 600, fig.width = 8)

library(dplyr)
library(DT)
library(knitr)
library(here)
library(qaqcmar)
library(sensorstrings)
library(stringr)
library(tidyr)

source(here("functions/subchunkify.R"))

dt_options1 <- list(
      dom = 'ft',
      paging = FALSE,
      searching = TRUE,
      pageLength = 500,
      #scrollY = "500px",
     # scrollX = "500px",
      columnDefs = list(list(className = 'dt-center', targets = "_all"))
)

dt_options2 <- list(
      dom = 'Bft',
      paging = FALSE,
      searching = TRUE,
      pageLength = 500,
      scrollY = "500px",
      scrollX = "500px",
      columnDefs = list(list(className = 'dt-center', targets = "_all")),
      buttons = c('copy', 'csv')
)

county <- params$county
depl_file <- params$depl_file

path_out <- paste(
  "R:/data_branches/water_quality/processed_data/flagged_data",
  county, sep = "/"
)

file_name <- sub(".*/", "", depl_file, perl = TRUE)

```


```{r, apply-qc-tests}
#| include: false

dat_raw <- readRDS(depl_file)

vars <- dat_raw %>% 
  ss_pivot_longer() %>% 
  distinct(variable)
vars <- vars$variable

# if sensor depth was not measured, do not run qc_test_depth_crpsscheck
if("sensor_depth_measured_m" %in% vars) {
  qc_tests = c(
    "grossrange", "climatology", "rolling_sd", "spike", "depth_crosscheck"
  )
} else{
  qc_tests = c("grossrange", "climatology", "rolling_sd", "spike")
}

dat <- dat_raw %>% 
  qc_test_all(qc_tests = qc_tests, join_column_spike = "sensor_type") 
#colnames(dat) <- str_remove_all(colnames(dat), "value_")

# filter these cols out before exporting???
# # there are no thresholds for these var-test combinations, so the whole column
# # will be flagged "Not Evaluated"
# if("climatology_flag_salinity_psu" %in% colnames(dat)) {
#   dat <- dat %>% select(-climatology_flag_salinity_psu)
# }
# 
# if("climatology_flag_sensor_depth_measured_m" %in% colnames(dat)) {
#   dat <- dat %>% select(-climatology_flag_sensor_depth_measured_m)
# }

#################################################################
#### EXPORT ####################################################
saveRDS(dat, paste(path_out, file_name, sep = "/"))
###############################################################
###############################################################


station <- unique(dat$station)
depl_range <- unique(dat$deployment_range)
```

# `r station`: `r depl_range`

## Deployment Details

```{r}
dat %>% 
  select(county, waterbody, station, lease, latitude, longitude,
         deployment_range, string_configuration) %>% 
  distinct() %>% 
  t() %>% 
  kable()
```


## Sensor Details

```{r}

dat_long <- dat %>% 
  qc_pivot_longer(qc_tests = qc_tests) %>% 
  select(-c(waterbody, lease, latitude, longitude, string_configuration)) 

dat_long %>% 
  select(
    variable, 
    sensor_depth = sensor_depth_at_low_tide_m, 
    sensor_type, sensor_serial_number
  ) %>% 
  distinct() %>% 
  datatable(options = dt_options1, rownames = FALSE)
```


# QC Summary

```{r}
dat_long %>% 
  qc_summarise_flags() %>% 
  # filter(
  #   
  # )
  datatable(options = dt_options2, rownames = FALSE, extensions = 'Buttons')
```

# QC Figures

```{r} 
#| message: FALSE
#| results: asis

if("sensor_depth_measured_m" %in% vars) {
  
  cat('\n## depth_crosscheck \n')
  
  p <- qc_plot_flags(dat_long, qc_tests = "depth_crosscheck")
  
  subchunkify(p$depth_crosscheck, fig_height = 2.75, fig_width = 8.5)
  
  qc_tests <- qc_tests[-which(qc_tests == "depth_crosscheck")]
  
}


for(i in seq_along(vars)){
  
  var_i <- vars[i]
  
  cat('\n##', var_i, '\n')
  
  cat('\n')
  
  for(j in seq_along(qc_tests)) {
    
    test_j <- qc_tests[j]
    
    # climatology test not applied to these variables
    if(!(test_j == "climatology" & 
         (var_i == "salinity_psu" | var_i == "sensor_depth_measured_m"))) {
      
      cat('\n###', test_j, '\n')
      
      # subset data to variable of interest
      dat_j <- dat_long %>%
        filter(variable == var_i) 
      
      # height of figure j
      n_sensor <- length(unique(dat_j$sensor_serial_number))
      
      if(n_sensor == 1) h = 2.25
      if(n_sensor > 1) h = 2.25 * n_sensor
      
      p <- qc_plot_flags(dat_j, qc_tests = test_j)
      
      subchunkify(p[[1]][[1]], fig_height = h, fig_width = 8.5)
      
      cat('\n')
    }
  }
}

```


